<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoluATM - Cash Withdrawal</title>
    <!-- FORCE DEPLOY: 2025-01-12-15:15 -->
    
    <!-- Eruda Mobile Debugging Console -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>
        try {
            eruda.init();
            console.log('‚úÖ Eruda initialized successfully');
        } catch (e) {
            console.log('‚ùå Eruda failed to initialize:', e);
        }
    </script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .logo {
            font-size: 32px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 16px;
            color: #7f8c8d;
        }
        
        .amount-display {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
        }
        
        .amount-value {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .amount-desc {
            opacity: 0.9;
            font-size: 14px;
        }
        
        .action-button {
            width: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 15px 0;
            transition: all 0.3s ease;
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }
        
        .action-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status-message {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 500;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            font-size: 12px;
            color: #95a5a6;
        }

        .debug-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">üèß RoluATM</div>
            <div class="subtitle">World ID Verified Cash Withdrawal</div>
        </div>
        
        <div class="amount-display">
            <div class="amount-value">$10.00</div>
            <div class="amount-desc">Cash Withdrawal + $0.50 fee</div>
        </div>
        
        <div id="status-message" class="status-message" style="display: none;"></div>
        
        <button id="withdraw-btn" class="action-button">
            Withdraw $10.50
        </button>

        <div id="debug-info" class="debug-info" style="display: block;"></div>
        
        <div id="console-output" style="background: #000; color: #0f0; padding: 10px; margin: 10px 0; font-family: monospace; font-size: 10px; max-height: 300px; overflow-y: auto; border-radius: 5px;"></div>
        
        <div class="footer">
            Powered by World ID ‚Ä¢ Secure ‚Ä¢ Private
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('=== DOM CONTENT LOADED ===');
            console.log('RoluATM initializing...');
            
            // Create aggressive on-page debugging console
            let consoleOutput;
            if (!document.getElementById('debug-console')) {
                consoleOutput = document.createElement('div');
                consoleOutput.id = 'debug-console';
                consoleOutput.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; 
                    background: #000; color: #0f0; font-family: monospace; 
                    font-size: 12px; padding: 10px; max-height: 200px; 
                    overflow-y: auto; z-index: 9999; border-bottom: 2px solid #0f0;
                `;
                document.querySelector('.container').appendChild(consoleOutput);
            } else {
                consoleOutput = document.getElementById('debug-console');
            }
            
            // AGGRESSIVE ON-PAGE DEBUGGING
            const originalLog = console.log;
            const originalError = console.error;
            
            function addToPageConsole(type, ...args) {
                try {
                    const timestamp = new Date().toLocaleTimeString();
                    const message = args.map(arg => 
                        typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                    ).join(' ');
                    
                    const div = document.createElement('div');
                    div.style.color = type === 'error' ? '#f00' : '#0f0';
                    div.textContent = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
                    consoleOutput.appendChild(div);
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                } catch (e) {
                    // Fallback if even this fails
                    const fallback = document.createElement('div');
                    fallback.textContent = 'DEBUG ERROR: ' + e.message;
                    fallback.style.color = '#f00';
                    consoleOutput.appendChild(fallback);
                }
            }
            
            // Override console methods to show on page
            console.log = function(...args) {
                originalLog.apply(console, args);
                addToPageConsole('log', ...args);
            };
            
            console.error = function(...args) {
                originalError.apply(console, args);
                addToPageConsole('error', ...args);
            };
            
            // Start debugging immediately
            console.log('=== ROLUATM DEBUG START ===');
            console.log('Page loaded at:', new Date().toISOString());
            console.log('User Agent:', navigator.userAgent);
            console.log('URL:', window.location.href);
            console.log('üîÑ Cache bust:', Date.now()); // Force fresh deployment
            
            // Check for World App objects
            console.log('window.WorldApp exists:', !!window.WorldApp);
            console.log('window.MiniKit exists:', !!window.MiniKit);
            console.log('typeof window.MiniKit:', typeof window.MiniKit);
            
            // Try to find MiniKit in ALL possible locations
            const allPossibleMiniKitLocations = [
                'window.MiniKit',
                'window.WorldApp.MiniKit', 
                'window.parent.MiniKit',
                'window.top.MiniKit',
                'window.frames[0].MiniKit',
                'globalThis.MiniKit',
                'self.MiniKit'
            ];
            
            console.log('=== SEARCHING FOR MINIKIT IN ALL LOCATIONS ===');
            allPossibleMiniKitLocations.forEach(location => {
                try {
                    const value = eval(location);
                    console.log(`${location}:`, !!value, typeof value);
                    if (value) {
                        console.log(`Found MiniKit at ${location}:`, Object.keys(value));
                    }
                } catch (e) {
                    console.log(`${location}: Error -`, e.message);
                }
            });
            
            // Check if we're actually in World App environment
            const isInWorldApp = !!(window.WorldApp || 
                                   window.location.href.includes('worldapp://') ||
                                   window.navigator.userAgent.includes('WorldApp') ||
                                   window.location.href.includes('world.org'));
            
            console.log('=== ENVIRONMENT CHECK ===');
            console.log('Is in World App:', isInWorldApp);
            console.log('User Agent contains WorldApp:', window.navigator.userAgent.includes('WorldApp'));
            console.log('URL contains worldapp://', window.location.href.includes('worldapp://'));
            console.log('URL contains world.org:', window.location.href.includes('world.org'));
            
            if (window.WorldApp) {
                console.log('‚úÖ WorldApp found! Checking for MiniKit...');
                console.log('Supported commands:', window.WorldApp.supported_commands);
                
                // Check if verify and pay commands are supported
                const verifySupported = window.WorldApp.supported_commands.find(cmd => cmd.name === 'verify');
                const paySupported = window.WorldApp.supported_commands.find(cmd => cmd.name === 'pay');
                
                console.log('Verify command supported:', !!verifySupported);
                console.log('Pay command supported:', !!paySupported);
                
                // Try to find MiniKit in different locations
                const miniKitLocations = [
                    window.MiniKit,
                    window.WorldApp.MiniKit,
                    window.parent?.MiniKit,
                    window.top?.MiniKit
                ];
                
                let foundMiniKit = null;
                miniKitLocations.forEach((location, index) => {
                    if (location) {
                        console.log(`Found MiniKit at location ${index}:`, location);
                        foundMiniKit = location;
                    }
                });
                
                // Try to load MiniKit dynamically if not found
                if (!foundMiniKit) {
                    console.log('‚ö†Ô∏è MiniKit not found, trying to load dynamically...');
                    
                    try {
                        // Try to load MiniKit script dynamically
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/@worldcoin/minikit-js@latest/dist/minikit.js';
                        
                        const loadPromise = new Promise((resolve, reject) => {
                            script.onload = () => {
                                console.log('‚úÖ MiniKit script loaded dynamically');
                                console.log('window.MiniKit after dynamic load:', window.MiniKit);
                                if (window.MiniKit) {
                                    foundMiniKit = window.MiniKit;
                                    resolve(window.MiniKit);
                                } else {
                                    reject(new Error('MiniKit still not available after script load'));
                                }
                            };
                            script.onerror = (error) => {
                                console.error('‚ùå Failed to load MiniKit script:', error);
                                reject(error);
                            };
                        });
                        
                        document.head.appendChild(script);
                        
                        // Wait for script to load with timeout
                        const timeoutPromise = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('MiniKit load timeout')), 5000);
                        });
                        
                        try {
                            await Promise.race([loadPromise, timeoutPromise]);
                        } catch (error) {
                            console.error('Failed to load MiniKit dynamically:', error);
                        }
                    } catch (error) {
                        console.error('Error loading MiniKit:', error);
                    }
                }
                
                if (foundMiniKit && foundMiniKit.commandsAsync) {
                    console.log('‚úÖ MiniKit.commandsAsync found!');
                    
                    // Try to install/initialize MiniKit
                    try {
                        if (foundMiniKit.install) {
                            console.log('Installing MiniKit with appId:', APP_CONFIG.appId);
                            foundMiniKit.install(APP_CONFIG.appId);
                            console.log('‚úÖ MiniKit installed successfully');
                        }
                        
                        if (foundMiniKit.isInstalled && !foundMiniKit.isInstalled()) {
                            console.log('‚ö†Ô∏è MiniKit not installed, trying to install...');
                            foundMiniKit.install(APP_CONFIG.appId);
                        }
                    } catch (error) {
                        console.log('MiniKit install error (may be normal):', error.message);
                    }
                    
                    setButtonState('Withdraw $10.50', false);
                    showStatus('Ready to withdraw. Click to verify with World ID.', 'success');
                    
                    // Add click event listener with debugging
                    console.log('Adding click event listener to withdraw button...');
                    const withdrawBtn = document.getElementById('withdraw-btn');
                    
                    if (withdrawBtn) {
                        withdrawBtn.addEventListener('click', function(event) {
                            console.log('üî• BUTTON CLICKED! Event:', event);
                            event.preventDefault();
                            event.stopPropagation();
                            console.log('Calling handleWithdrawWithMiniKit...');
                            handleWithdrawWithMiniKit(foundMiniKit);
                        });
                        console.log('‚úÖ Click event listener added successfully');
                    }
                } else if (verifySupported && paySupported) {
                    // Fallback: Try to use postMessage to communicate with World App
                    console.log('‚ö†Ô∏è MiniKit not found, trying postMessage approach...');
                    setButtonState('Withdraw $10.50', false);
                    showStatus('Ready to withdraw. Click to verify with World ID.', 'success');
                    
                    const withdrawBtn = document.getElementById('withdraw-btn');
                    if (withdrawBtn) {
                        withdrawBtn.addEventListener('click', function(event) {
                            console.log('üî• BUTTON CLICKED! Using postMessage approach');
                            event.preventDefault();
                            event.stopPropagation();
                            handleWithdrawWithPostMessage();
                        });
                    }
                } else {
                    showStatus('‚ùå Required commands not supported by this World App version', 'error');
                    setButtonState('Unsupported', true);
                }
            } else {
                console.log('‚ùå window.WorldApp is undefined');
                
                // Check for alternative MiniKit locations
                const alternatives = ['minikit', 'Minikit', 'MINIKIT', 'worldcoin', 'Worldcoin'];
                alternatives.forEach(key => {
                    if (window[key]) {
                        console.log(`Found alternative: window.${key}`, typeof window[key]);
                    }
                });
                
                // List all window properties that might be related
                const windowKeys = Object.keys(window);
                const relevantKeys = windowKeys.filter(key => 
                    key.toLowerCase().includes('mini') || 
                    key.toLowerCase().includes('world') ||
                    key.toLowerCase().includes('coin')
                );
                console.log('Relevant window keys:', relevantKeys);
                
                // Show helpful error message
                showStatus('‚ùå Not running in World App environment', 'error');
                setButtonState('World App Required', true);
            }
            
            // Add helpful developer portal setup check
            console.log('=== DEVELOPER PORTAL SETUP CHECK ===');
            console.log('App ID:', APP_CONFIG.appId);
            console.log('Action:', APP_CONFIG.action);
            console.log('‚ö†Ô∏è IMPORTANT: Make sure you have created an Incognito Action in Developer Portal:');
            console.log('1. Go to Developer Portal > Configuration > Incognito Actions');
            console.log('2. Create action with ID: "withdraw-cash"');
            console.log('3. Set max verifications (e.g., 1 per day)');
            console.log('4. For payments, whitelist wallet address:', APP_CONFIG.walletAddress);
            
            // Continue with the rest of the app initialization
            initializeApp();
        });
        
        // Global helper functions and elements (moved outside initializeApp)
        let elements = {};
        
        function showStatus(message, type) {
            const statusElement = document.getElementById('status-message');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `status-message status-${type}`;
                statusElement.style.display = 'block';
                console.log(`Status: ${type.toUpperCase()} - ${message}`);
            } else {
                console.log(`Status (no element): ${type.toUpperCase()} - ${message}`);
            }
        }

        function setButtonState(text, disabled = false) {
            const withdrawBtn = document.getElementById('withdraw-btn');
            if (withdrawBtn) {
                withdrawBtn.innerHTML = text;
                withdrawBtn.disabled = disabled;
                console.log(`Button state: "${text}", disabled: ${disabled}`);
            } else {
                console.error('‚ùå Could not find withdraw button for setButtonState');
            }
        }
        
        // Application configuration
        const APP_CONFIG = {
            appId: 'app_263013ca6f702add37ad338fa43d4307',
            action: 'withdraw-cash',
            walletAddress: '0x742fd484b63E7C9b7f34FAb65A8c165B7cd5C5e8',
            sessionId: new URLSearchParams(window.location.search).get('session') || 'demo-session-' + Date.now()
        };
        
        // New function to handle withdrawal using MiniKit SDK
        async function handleWithdrawWithMiniKit(miniKit) {
            try {
                console.log('=== WITHDRAW ATTEMPT WITH MINIKIT ===');
                console.log('Using MiniKit SDK:', miniKit);
                
                showStatus('Starting World ID verification...', 'info');
                setButtonState('<span class="spinner"></span>Verifying...', true);

                // Use MiniKit SDK for verification
                const { finalPayload: verifyFinalPayload } = await miniKit.commandsAsync.verify({
                    action: APP_CONFIG.action,
                    signal: APP_CONFIG.sessionId,
                    verification_level: 'orb'
                });

                console.log('Verify result:', verifyFinalPayload);

                if (verifyFinalPayload.status === 'error') {
                    throw new Error(verifyFinalPayload.error_message || 'World ID verification was rejected or failed.');
                }
                
                showStatus('‚úÖ World ID verified! Preparing payment...', 'success');

                const initiateResponse = await fetch('/api/initiate-payment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        payload: verifyFinalPayload,
                        amount: 10.50
                    })
                });

                const paymentData = await initiateResponse.json();
                if (!initiateResponse.ok || !paymentData.success) {
                    throw new Error(paymentData.detail || 'Failed to initiate payment on the server.');
                }
                
                showStatus('Please confirm the payment in World App...', 'info');

                // Use MiniKit SDK for payment
                const { finalPayload: payFinalPayload } = await miniKit.commandsAsync.pay({
                    reference: paymentData.reference,
                    to: paymentData.to,
                    tokens: paymentData.tokens,
                    description: paymentData.description
                });
                
                console.log('Pay result:', payFinalPayload);
                
                const confirmResponse = await fetch('/api/confirm-payment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        payment_id: paymentData.payment_id,
                        finalPayload: payFinalPayload
                    })
                });

                const confirmData = await confirmResponse.json();
                if (!confirmResponse.ok || !confirmData.success) {
                    throw new Error(confirmData.message || 'Payment confirmation failed on the server.');
                }

                showStatus(`‚úÖ Payment successful! Tx: ${confirmData.tx_hash.substring(0, 10)}...`, 'success');
                setButtonState('Done!', true);

            } catch (error) {
                console.error('Withdrawal Error:', error);
                showStatus(`‚ùå Error: ${error.message}`, 'error');
                setButtonState('Try Again', false);
                updateDebugInfo();
            }
        }
        
        // Fallback function using postMessage approach
        async function handleWithdrawWithPostMessage() {
            try {
                console.log('=== WITHDRAW ATTEMPT WITH POSTMESSAGE ===');
                console.log('Using postMessage to communicate with World App');
                
                showStatus('Starting World ID verification...', 'info');
                setButtonState('<span class="spinner"></span>Verifying...', true);

                // Try postMessage approach for verification
                const verifyPromise = new Promise((resolve, reject) => {
                    const messageHandler = (event) => {
                        console.log('Received message:', event.data);
                        if (event.data.eventType === 'verify_result') {
                            window.removeEventListener('message', messageHandler);
                            if (event.data.eventData.status === 'success') {
                                resolve(event.data.eventData);
                            } else {
                                reject(new Error(event.data.eventData.error_message || 'Verification failed'));
                            }
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    
                    // Send verify command via postMessage
                    const verifyMessage = {
                        eventType: 'verify',
                        eventData: {
                            action: APP_CONFIG.action,
                            signal: APP_CONFIG.sessionId,
                            verification_level: 'orb'
                        }
                    };
                    
                    console.log('Sending verify message:', verifyMessage);
                    window.parent.postMessage(JSON.stringify(verifyMessage), '*');
                    
                    // Timeout after 30 seconds
                    setTimeout(() => {
                        window.removeEventListener('message', messageHandler);
                        reject(new Error('Verification timeout'));
                    }, 30000);
                });

                const verifyResult = await verifyPromise;
                console.log('Verify result:', verifyResult);
                
                showStatus('‚úÖ World ID verified! Preparing payment...', 'success');
                
                // Continue with backend payment flow...
                const initiateResponse = await fetch('/api/initiate-payment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        payload: verifyResult,
                        amount: 10.50
                    })
                });

                const paymentData = await initiateResponse.json();
                if (!initiateResponse.ok || !paymentData.success) {
                    throw new Error(paymentData.detail || 'Failed to initiate payment on the server.');
                }
                
                showStatus('Please confirm the payment in World App...', 'info');

                // Try postMessage approach for payment
                const payPromise = new Promise((resolve, reject) => {
                    const messageHandler = (event) => {
                        console.log('Received payment message:', event.data);
                        if (event.data.eventType === 'pay_result') {
                            window.removeEventListener('message', messageHandler);
                            if (event.data.eventData.status === 'success') {
                                resolve(event.data.eventData);
                            } else {
                                reject(new Error(event.data.eventData.error_message || 'Payment failed'));
                            }
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    
                    const payMessage = {
                        eventType: 'pay',
                        eventData: {
                            reference: paymentData.reference,
                            to: paymentData.to,
                            tokens: paymentData.tokens,
                            description: paymentData.description
                        }
                    };
                    
                    console.log('Sending pay message:', payMessage);
                    window.parent.postMessage(JSON.stringify(payMessage), '*');
                    
                    setTimeout(() => {
                        window.removeEventListener('message', messageHandler);
                        reject(new Error('Payment timeout'));
                    }, 30000);
                });

                const payResult = await payPromise;
                console.log('Pay result:', payResult);
                
                const confirmResponse = await fetch('/api/confirm-payment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        payment_id: paymentData.payment_id,
                        finalPayload: payResult
                    })
                });

                const confirmData = await confirmResponse.json();
                if (!confirmResponse.ok || !confirmData.success) {
                    throw new Error(confirmData.message || 'Payment confirmation failed on the server.');
                }

                showStatus(`‚úÖ Payment successful! Tx: ${confirmData.tx_hash.substring(0, 10)}...`, 'success');
                setButtonState('Done!', true);

            } catch (error) {
                console.error('Withdrawal Error:', error);
                showStatus(`‚ùå Error: ${error.message}`, 'error');
                setButtonState('Try Again', false);
                updateDebugInfo();
            }
        }
        
        // Global debug info function
        function updateDebugInfo() {
            const debugDiv = document.getElementById('debug-info');
            if (debugDiv) {
                debugDiv.style.display = 'block';
                debugDiv.innerHTML = `
                    <strong>Debug Info:</strong><br>
                    URL: ${window.location.href}<br>
                    User Agent: ${navigator.userAgent}<br>
                    window.WorldApp: ${!!window.WorldApp}<br>
                    window.MiniKit: ${!!window.MiniKit}<br>
                    typeof MiniKit: ${typeof window.MiniKit}<br>
                    MiniKit keys: ${window.MiniKit ? Object.keys(window.MiniKit) : 'N/A'}<br>
                    Is World App: ${typeof window !== 'undefined' && 
                                   (window.location.href.includes('worldapp://') || 
                                    window.navigator.userAgent.includes('WorldApp') ||
                                    window.WorldApp ||
                                    window.location.href.includes('world.org'))}
                `;
            }
        }
        
        function initializeApp() {
            console.log('=== INITIALIZING APP ===');

            // Check if we're in World App environment
            const isInWorldApp = typeof window !== 'undefined' && 
                               (window.location.href.includes('worldapp://') || 
                                window.navigator.userAgent.includes('WorldApp') ||
                                window.WorldApp ||
                                window.location.href.includes('world.org'));

            console.log('Environment check:', {
                isInWorldApp,
                userAgent: navigator.userAgent,
                location: window.location.href,
                hasWorldApp: !!window.WorldApp,
                hasWorldAppInUrl: window.location.href.includes('worldapp://'),
                hasWorldAppInUA: window.navigator.userAgent.includes('WorldApp'),
                hasWorldOrgInUrl: window.location.href.includes('world.org')
            });

            // Show debug info on page
            updateDebugInfo();
        }
    </script>
</body>
</html> 